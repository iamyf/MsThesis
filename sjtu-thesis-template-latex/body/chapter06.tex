\chapter{后续问题研究讨论}
\label{chap:fut}

在第\ref{chap:tnpa-equiv}章和第\ref{chap:tnpa-alg}章中，我们给出了一个用于判定tnPA进程$\weq_{REG}$和$\beq_{REG}$问题的算法，并分析了它的时间复杂度。同时这个问题对于tnBPA和tnBPP依然成立。本章我们将对一些我们十分感兴趣，但是并未被解决的Regularity问题进行讨论。

有了tnPA上的结论，一个非常自然的问题，就是如果将完全正规化条件去掉，那我们是否还有可判定性的结论。即考虑正规化PA的$\weq_{REG}$和$\beq_{REG}$问题。由于PA模型的复杂性，所以首先，我们可以分别考虑串行和并行的子模型nBPA和nBPP上的相关问题。我们考虑这两个模型的另一个原因是，他们的$\beq$等价性验证问题已经分别被解决\cite{CzerwiAski2011,Fu2013}，而且nBPA上的$\beq_{REG}$也有了可判定性结论\cite{Fu2013}。所以我们有理由相信，nBPP的$\beq_{REG}$问题有希望在近期内被攻克。

另外，对于tnPN上，我们也可以利用本文中的一些直观，在对模型进行一些限定之后，找到$\weq_{REG}$和$\beq_{REG}$问题的一些思路。

我们在进行无限状态系统验证问题的研究时，另一个十分重要的研究目标就是给定一个问题，我们需要设法证明他的算法复杂性的下界或者不可判定性。我们统称这两类问题为下界问题。我们将在本章最后，讨论Regularity相关的下界问题。

\section{正规化BPP的$\beq_{REG}$问题}
\label{sec:nbpp}

本节我们將对nBPP的$\beq_{REG}$的解决思路做一些简单的讨论。我们将在着重讨论$\not\beq_{REG}$的半可判定性。我们希望能够证明：

\begin{conj}[nBPP 的$\beq_{REG}$问题]\label{conj:nbpp-reg}
nBPP的$\beq_{REG}$问题是可判定的。
\end{conj}

Czerwi{\'n}ski, Hofman 和Lasota在2011年在\cite{CzerwiAski2011}中给出了nBPP的$\beq$等价的可判定性证明。自从有了这一结论之后，nBPP上的$\beq_{REG}$问题就成为了等待解决的公开问题。

\begin{lem}[nBPP的$\beq$可判定性 nBPP $\beq$ Decidability]\label{lemma:nbpp-beq}
Normed BPP的$\beq$是可判定的。
\end{lem}

这样，我们利用引理\ref{lemma:nbpp-beq}和引理\ref{lemma:semi-dec}可知

\begin{cor}[nBPP的$\beq_{REG}$的半可判定性 nBPP $\beq_{REG}$ Semi-Decidability]\label{cor:nbpp-beq-reg-semi}
Normed BPP的$\beq$是半可判定的。
\end{cor}

有了\cite{Fu2013}中nBPA的$\beq$和$\beq_{REG}$问题的可判定性结论，我们有理由相信，nBPP的$\beq_{REG}$也是可判定的。有了推论\ref{cor:nbpp-beq-reg-semi}，现在我们只需要证明$\not\beq_{REG}$是半可判定的。一个最直接的思路是找到一个$\not\beq_{REG}$的充分必要条件，然后证明这个条件是半可判定的。

为了证明无限性的半可判定，我们要去寻找nBPP生成无限个互不$\beq$等价的状态的原因。

我们知道，我们可以用一个整数向量来表示并行进程，其中每个整数表示对应进程变量上的指数。定一个nBPP进程$(\alpha,\Delta)$，我们将其中能指数上能到达无穷大的进程变量的集合记为$Inf(\alpha,\Delta)$。我们有引理\ref{lemma:nbpp-infi-var-semi}：

\begin{lem}\label{lemma:nbpp-infi-var-semi}
给定一个nBPP进程$(\alpha,\Delta)$，$Inf(\alpha,\Delta)$是半可判定的。
\end{lem}

\begin{proof}
这个集合是一个半线性集合(Semilinear Set)，证明略。
\end{proof}

为了简化问题，我们提出引理\ref{lemma:nbpp-infi-var}，从而将研究的注意力集中在$Inf(\alpha,\Delta)$上：

\begin{lem}\label{lemma:nbpp-infi-var}
给定一个nBPP进程$(\alpha,\Delta)$，如果$Inf(\alpha,\Delta)=\emptyset$那么它是Regular的。
\end{lem}

\begin{proof}
假设给定进程满足条件，那么它只能在语言上生成有限个不同的进程表达式。
\end{proof}

如果我们需要在语言上能得到无限个互不相同的进程项，那么我们必须能使得向量中某个整数可以无限增大。另外，BPP是一个上下文无关的模型，所以我们对于进程的行为每次只需要考虑一个进程变量。我们这里仅仅需要考虑那些可以在指数上无限增大的进程变量，即集合$Inf(\alpha,\Delta)$中进程变量的性质。

然而，这仅仅是一个$\beq_{REG}$的必要条件，事实表明，并非所有的$Inf(\alpha,\Delta)$中的进程都会产生无限的状态。为了进一步我们所考虑的进程，我们有引理\ref{lemma:nbpp-beq-reg-infi-norm}

\begin{lem}\label{lemma:nbpp-beq-reg-infi-norm}
给定一个nBPP进程$(\alpha,\Delta)$，如果存在进程变量$X\in Inf(\alpha,\Delta)$，而且$\|X\|>0$，那么该进程是$\not\beq_{REG}$的。
\end{lem}

\begin{proof}
由引理\ref{lemma:infi-path}，该进程的模显然可以任意增大(但不是$\infty$)，得证。
\end{proof}

由引理\ref{lemma:nbpp-infi-var-semi}和\ref{lemma:nbpp-beq-reg-infi-norm}可知这我们无需考虑那些$Norm>0$的进程，因为这种情况可以简单的判定，即检测是否$Inf(\alpha,\Delta)$中有$Norm>0$的进程变量。

我们就将问题简化为，只需要对$Inf(\alpha,\Delta)$中$Norm=0$的进程进行讨论即可。

由这一思路，我们将定义一种\emph{稳定(Stable)}的进程变量。

\begin{defn}[稳定的进程变量 Stable Variable]\label{def:stable-var}
给定一个nBPP进程$(\alpha,\Delta)$，一个进程变量$X \in Var(\Delta)$是稳定(Stable)的如果它满足如下性质：
\begin{itemize}
	\item 对于所有$Y\in Reach(X)$，我们有$\|Y\|=0$。
	\item 存在$k\in \mathbb{N},k\geq 1$，满足$X^{k-1}\not\beq X^k\beq X^{k+1}$。
\end{itemize}
\end{defn}

我们无需考虑那些$Norm>0$的进程显然，我们有引理\ref{lemma:stable-var}

\begin{lem}\label{lemma:stable-var}
给定一个nBPP进程$(\alpha,\Delta)$，它是$\beq_{REG}$的，如果所有$X\in Var(\Delta)$都是稳定的进程变量。
\end{lem}

\begin{proof}
根据$\beq$的同余(Congurence)性，我们显然可证。
\end{proof}

这样，对于半可判定性的最后一种情况，我们只需要证明所有$Inf(\alpha,\Delta)$中的进程变量，如果是稳定的，那么必然存在可以\emph(有效计算(Effectively Computable)的常数$C$，使得$k<C$。

\begin{lem}[nBPP $\not\beq_{REG}$ 半可判定算法终止性 Termination of Semi-Decidability Procedure for nBPP $\not\beq_{REG}$]\label{lemma:term}
给定一个nBPP进程$(\alpha,\Delta)$，如果存在可有效计算(Effectively Computable)的常数$C$，使得如果$V\in Var(\Delta)$是稳定的进程变量，那么存在满足$X^{k-1}\not\beq X^k\beq X^{k+1}$，且$k\leq C$。

则$nBPP$的$\not\beq_{REG}$是半可判定的。
\end{lem}

\begin{proof}
我们根据进程变量的模分情况讨论：
\begin{itemize}
\item 给定一个nPP进程$(\alpha,\Delta)$，对于$Inf(\alpha,\Delta)$中的$Norm>0$的进程，容易判定。
\item 对于$Norm=0$的进程，如果存在这样可以有效计算的$C$，那么对于每个进程变量，我们都可以有效得判定其是否是稳定的。假设对于某个进程变量$X$，超过$C$仍然找不到对应的$k$，那么由假设可知$X$不是稳定的。我们很容易得到无限个互不$\beq$等价的状态$X^1\not\beq X^2\not\beq\ldots$。如果这样，过程终止，该进程是$\not\beq_{REG}$的。
\end{itemize}
于是，如果能有效计算这样的$C$，那么$\not\beq{REG}$是半可判定的。
\end{proof}

结合推论\ref{cor:nbpp-beq-reg-semi}和引理\ref{lemma:term}，我们可知，如果能有效的计算出这样的常数$C$，那么$\beq_{REG}$是可判定的。

从直观上来分析，这个常数$C$表示了单个进程变量组成的表达式能产生不同状态的上限。为了有效计算这个常数，一个思路是给进程变量确定一个合理的序关系，然后从这个序关系上，自底向上地归纳地求解。需要注意的是，为了能够有效地计算，这个界也只能是和输入的进程规则相关的。

尽管迄今为止，有效的计算$C$的方法还没有被发现。但是种种迹象表明，沿着这个思路继续探究，必定能够完全的解决nBPP上的$\beq_{REG}$问题。

\section{完全正规化PN的$\weq_{REG}$和$\beq_{REG}$问题}
\label{sec:tnPN}

Petri Net是一个在程序分析，软件工程和协议验证方面常用的模型。它是PRS中的完全并行化的一个进程模型。由\cite{Jancar1996}和推论\ref{cor:pn-beq-und}可知，该模型的Regularity问题在仅考虑强互模拟的情况下，是可判定的，相关的$\weq_{REG}$和$\beq_{REG}$问题都是不可判定的。所以我们在研究这两个问题时，至少需要加上正规化限制。

然而，经过第\ref{sec:nbpp}节中的研究，我们知道即使是nPN的一个子模型nBPP，它的$\beq_{REG}$问题尚未完全解决。

为了研究PN下关于包含内部动作的互模拟关系的Regularity问题，在第\ref{chap:tnpa-equiv}章和第\ref{chap:tnpa-alg}章中PA工作的启发下，我们很自然的可以想到，可以先试图解决完全正规化限制下的PN的$\weq_{REG}$和$\beq_{REG}$问题。在tnPA的模型中，完全正规化条件可以有效地将进程所生成的表达式的语言的数量和其状态的数量建立一定的约束关系，这是进行进程有限性判定的关键。在tnPN的模型中，我们也可以尝试沿着这个思路进行研究。

我们知道，类似PN的并行进程模型都可以用Vector Addition System(VAS)进行表示。由\cite{Rackoff1978,Cardoza1976}，我们有一个关于VAS的有限性(Boundedness)的复杂度结论：

\begin{lem}[VAS Boundedness]\label{lemma:vas}
给定一个VAS，判定是否其是否只能达到有限的数值(Boundedness)的问题是EXPSPACE完全的。
\end{lem}

我们知道由于PN和VAS是等价的模型，所以我们有引理\ref{lemma:pn-bound}

\begin{lem}\label{lemma:pn-bound}
给定一个PN进程，其中是否有一个变量的指数能达到无穷大的问题是EXPSPACE完全的。
\end{lem}

我们发现，引理\ref{lemma:pn-bound}中的条件，很明显是$\not\weq_{REG}$和$\not\beq_{REG}$的一个必要条件。原因是只有能生成语言上互不相同的无穷多个进程，才可能生成无穷多个互不互模拟的进程。

一个很自然的思路就是我们可以试图去证明这个条件也是tnPN$\not\weq_{REG}$和$\not\beq_{REG}$的一个充分条件。从而利用引理\ref{lemma:pn-bound}中的结论来对该问题进行判定。

现在遇到的困难是，由于tnPN并没有类似于上下文无关模型(BPA，BPP和PA)中的模对加法的同余性，所以我们没有办法直接通过简单的关于模的分析，来得到模可以不停增加的进程项序列。

现在该问题有两种可能的结果：

\begin{enumerate}
	\item 通过进一步分类tnPN中的进程变量，更精细地分析它的行为和规则。可以使用类似与归纳法的思路，从而证明进程的模增加的序列所需满足的条件。

如果成立，那么可以试图证明

\begin{conj}[tnPN $\weq_{REG}$和$\beq_{REG}$问题]\label{conj:tnpn-reg}
tnPN的$\weq_{REG}$和$\beq_{REG}$问题是EXPSPACE完全的。
\end{conj}

	\item 如果猜想\ref{conj:tnpn-reg}不成立，我们可以通过对\cite{Jancar1996}和推论\ref{cor:pn-beq-und}中的归约进一步分析，证明该问题是不可判定的。
\end{enumerate}

由作者对模型和等价关系的直观，个人更倾向于相信猜想\ref{conj:tnpn-reg}中EXPSPACE完全的结论成立。因为，完全正规化的条件从某种程度上限制了进程变量``消失''的能力，``消失''之前至少要留下``痕迹''。这就为进程表达式的语言上的无穷性和进程状态的语义上的无穷性提供了一个联系，使得Regularity的判定问题更加有可能被解决。而且，第一个猜想中的结论也是更有实际意义的，正如第\ref{chap:pre}章中提到的，我们更希望能得到复杂性上完全的结论。


\section{进程重写系统有限性问题的下界}
\label{sec:lower-bound}

不仅限于无限状态系统的验证问题，对于计算机理论中的所有问题，人们最感兴趣的都是是否能得到一个完备(Complete)的结论。

而完备的结论包括两个方面，一个是复杂性上界或者可判定性，前文中大部分篇幅所讨论的都是对这类结论的探究；另一方面则是复杂性下界或者不可判定性。直观的来说，上界刻画了一个问题现有的解决方法的复杂度，下界刻画了一个问题本身的解决难度。如果一个问题的上界和下届最终被证明是相同的复杂度，那么称这个问题为该复杂度下完备的，例如NP完备问题。只有证明了一个问题是完备的，我们才能说这个问题的复杂度已经被彻底研究了。

首先在方法上，我们进行进行问题下界的探究时，我们通常的方法就是\emph{归约(Reduction)}。即如果要证明某个问题的下界，那么我们可以选择一个该复杂性上的完备问题，然后证明对于该问题的一个实例，可以在该复杂性内生成一个原问题的实例。并且该问题的实例成立，当且仅当原问题所对应的实例成立。

最常见的利用归约证明问题下界的场景就是算法中常用的NP完全性证明。对于某个问题，我们所熟悉的方法就是找一个NP完全的问题，对于该问题然后在多项是时间内生成一个原问题的实例，再证明两个实例的等价性。这样就证明了原问题的NP难的性质。

类似的，对于PRS上的验证问题，我们在证明其下界时通常也需要选择一个某复杂度的完备性的问题，再针对该问题构造相应的PRS上满足相应性质的模型。由于互模拟关系有一个非常优美的博弈论描述(Game Theoretical Description)，我们就通常利用博弈论中的方法来进行相应进程的构造，这种思想叫\emph{防御者逼迫(Defencer's Forcing)}\cite{Jancar2008}。

接下来我们就在本文的最后部分对现在未知的一些PRS的Regularity问题的下界进行讨论。在研究的方向性上寻找一些灵感，从而得到一系列值得去研究的相关问题。

我们在第\ref{sec:prs-reg-result}节中总结PRS中Regularity问题相关结论时，已经将现有的结论按照不同的模型分别填在几个表格中。其中，我们还得到了推论\ref{cor:pn-beq-und}中Petri Net的$\beq_{REG}$问题的不可判定性。

通过对无限状态系统验证中几个问题下界结论的总结，我们可以发现，给定某个PRS中的模型，其Regularity问题的下界往往与Equivalence Checking问题相关，其下界的证明经常是通过Equivalence Checking问题直接构造一个归约，而证明的。例如在\cite{Srba2002b,Srba2002a}中，其BPA和BPP的Regularity问题的下界都是通过对应的Equivalence Checking问题归约而得到的。

下面首先列出几个我认为可以去思考的问题以及可能的结论：

\begin{enumerate}
\item 在\cite{Kiefer2012}中，BPA的$\seq$等价验证问题被证明为EXPTIME难的，但是这个证明并不能直接用来归约证明$\seq_{REG}$问题的EXPTIME下界。而现在BPA的$\seq_{REG}$问题的下界仅仅被证明是PSPACE难的\cite{Srba2002b}。直观的来说，这个下界是非常有可能被提高到EXPTIME难的。

我们可以尝试去证明：

\begin{conj}[BPA $\seq_{REG}$问题下界]\label{conj:bpa-seq-reg}
BPA的$\seq_{REG}$问题是EXPTIME难的。
\end{conj}

\item 在\cite{Fu2013}中，nBPA的$\beq_{REG}$问题被证明是可判定的，但是并没有证明任何原始递归的上界，同时也没有给出任何下界的证明。而相应的nBPA的$\weq_{REG}$问题仅仅是NP难的\cite{Srba2003,StriAbra1998}。

我们可以尝试去证明：

\begin{conj}[nBPA $\beq_{REG}$问题下界]\label{conj:nbpa-beq-reg}
nBPA的$\beq_{REG}$问题是NP难的。
\end{conj}

\item 在\cite{Srba2003}中，nBPP的$\weq_{REG}$问题都被证明是PSPACE难的，我们可以试图通过修改证明中构造的进程，使其满足$\beq_{REG}$性质。

我们可以尝试去证明：

\begin{conj}[nBPP $\beq_{REG}$问题下界]\label{conj:nbpp-beq-reg}
nBPP的$\beq_{REG}$问题是PSPACE难的。
\end{conj}

\item 对nPDA，我们也有$\weq_{REG}$问题是EXPTIME难的\cite{Kucera2002a,Srba2002b}。而对应的$\beq_{REG}$问题并没有给出下界结论。

我们可以尝试去证明：

\begin{conj}[nPDA $\beq_{REG}$问题下界]\label{conj:npda-beq-reg}
nPDA的$\beq_{REG}$问题是EXPTIME难的。
\end{conj}

\item 同理，对nPN，我们有$\weq_{REG}$问题是EXPSPACE难的\cite{Cardoza1976}。而对应的$\beq_{REG}$问题的下界还没有一个严格的证明。

我们可以尝试去证明：

\begin{conj}[nPN $\beq_{REG}$问题下界]\label{conj:npn-beq-reg}
nPN的$\beq_{REG}$问题是EXPSPACE难的。
\end{conj}
\end{enumerate}

以上几个问题，其中猜想\ref{conj:nbpa-beq-reg}，\ref{conj:nbpp-beq-reg}，\ref{conj:npda-beq-reg}，和\ref{conj:npn-beq-reg}，从直观上都可以直接对归约中构造的进程进行简单的修改，让其符合$\beq_{REG}$的性质，从而得到证明。而对于猜想\ref{conj:bpa-seq-reg}，则似乎没有那么简单。一个思路是重新找一个EXPTIME完全的问题，构造一个新的归约证明。

这一章中我们主要讨论了PRS中Regularity问题的研究现阶段继续前进的方向，相关问题的思路，以及可能的结论。提出了一些具有启发性的引理与猜想，为进一步的研究打下了基础。

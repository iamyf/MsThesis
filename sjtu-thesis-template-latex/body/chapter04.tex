\chapter{Totally Normed PA Regularity的充要条件}
\label{chap:tnpa-equiv}

在这一章中，我们将具体讨论和证明tnPA的$\weq_{REG}$和$\beq_{REG}$问题的充分必要条件，定理\ref{thm:tnpa-equiv}。这里将\cite{Kucera1996}中用于判定nPA的$\seq_{REG}$的一些技术应用到我们讨论的问题中，起到了很好的效果。这里证明的充要条件将会在第\ref{chap:tnpa-alg}章中的多项式算法中被判定。

这里需要说明的是，由于这些条件都需要是可判定的，在判定的过程中我们需要一个计算复杂性上可行的算法。这就意味着我们所给出条件的判定过程需要有一个确定的，有限的，可以有效计算的上界。否则判定算法上会发生状态数量的爆炸，整个过程就丧失了计算上的可行性。这个上界会在接下来的分析中一步步变得清晰，我们要遵守的一个原则是这个上界只能和输入进程的语法规则和初始状态的规模相关。

\section{PA模型定义}
\label{sec:pa-def}

为了问题研究的严谨性，我们这里在PRS的一般性定义\ref{def:prs}的基础上，给出PA的严格定义。

\begin{defn}[PA 定义]\label{def:pa}
一个PA系统是一个形如$X\act{a}\alpha$的有限转换规则的集合$\Delta$，一个PA表达式的语法定义为：
$$\alpha,\beta\Coloneqq X\mid \alpha.\beta\mid\alpha\parallel\beta\mid\alpha\llfloor\beta$$
其中用大写英文字母表示进程变量,希腊字母表示进程项(状态)。
相应的操作语义可以定义为一下规则
\[\begin{array}{ccc}
$\inference{\alpha\act{a}\beta\in\Delta}{\alpha\act{a}\beta}$ &
$\inference{\alpha\act{a}\alpha^{'}}{\alpha.\beta\act{a}\alpha^{'}.\beta}$ &
$\inference{\alpha\act{a}\alpha^{'}}{\alpha\| \beta\act{a}\alpha^{'}\|\beta}$ \\
 \\
$\inference{\beta\act{a}\beta^{'}}{\alpha\| \beta\act{a}\alpha \| \beta^{'}}$ &
$\inference{\alpha\act{a}\alpha^{'}}{\alpha\llfloor \beta\act{a}\alpha^{'}\|\beta}$ &
\end{array}\]
一个PA进程可以具体表示为$(\alpha,\Delta)$。
\end{defn}

我们用函数$Var(\_)$表示$\_$中所包含的进程变量。

我们要求一个PA中定义的所有进程变量$X_i\in Var(\Delta)$存在一个可达的状态$\alpha$满足$\X_i\in Var(\alpha)$。

另外，我们用$Length(\alpha)$表示$\alpha$中出现的进程变量的个数。

同时，我们限制在章里我们所关心的PA进程都是Totally Normed的。同时如果不特殊说明，我们证明中所用到的等价关系都是弱互模拟关系$\weq$。这些证明对于$\beq$都是成立的。

\section{进程状态的增长}
\label{sec:grow-prop}

给定一个tnPA的进程$(\alpha,\Delta)$，我们希望能找到导致它产生无限中不同状态的进程变量的集合。这些变量导致了进程状态所能产生的增长，是导致进程非Regularity的原因。

我们首先针对一个tnPA进程，定义两个十分有用的函数。

\begin{defn}[Fire 函数]\label{def:fire}
给定一个tnPA进程$(\alpha,\Delta)$
\begin{eqnarray*}
Fire(\alpha) &=& \left\{ \begin{array}{ll}
\emptyset & \mbox{if }\alpha=\epsilon\\
\{X\} & \mbox{if }\alpha=X\\
Fire(\beta_1) & \mbox{if }\alpha=\beta_1.\beta_2\mbox{ or }\alpha=\beta_1\llfloor\beta_2\\
Fire(\beta_1)\cup Fire(\beta_2) & \mbox{if }\alpha=\beta_1\|\beta_2
\end{array}\right.
\end{eqnarray*}
\end{defn}

$Fire()$函数会返回那些当前状态下潜在可以被激发(Active)的进程变量的集合。

\begin{defn}[Tail 函数]\label{def:tail}
给定一个tnPA进程$(\alpha,\Delta)$
\begin{eqnarray*}
Tail(\alpha) &=& \left\{ \begin{array}{ll}
\{X\} & \mbox{if }\alpha=X\\
\emptyset & \mbox{if }\alpha=\epsilon \mbox{ or } \alpha=\beta_1\|\beta_2 \mbox{ where } \beta_1\neq\epsilon\neq\beta_2\\
Tail(\beta_2)-Var(\beta_1) &\mbox{if }\alpha=\beta_1.\beta_2 \mbox{ or }\alpha=\beta_1\llfloor\beta_2\mbox{ where }\beta_1\neq\epsilon\neq\beta_2
\end{array}\right.
\end{eqnarray*}
\end{defn}

$Tail()$函数返回所有在当前状态下被阻塞(Block)，即必须先将别的变量转换成$\epsilon$，最后才能激发的进程变量的集合。

通过观察这两个函数的性质，我们能得到以下性质，引理\ref{lemma:tail}：

\begin{lem}\label{lemma:tail}
假设我们有$X\in Var(\alpha)$满足$X\notin Tail(\alpha)$，那么必然存在$\alpha'$，使得$\alpha\act{}^{*}\alpha'$，且$X\in Fire(\alpha')$且$Length(\alpha')\geq 2$。
\end{lem}

\begin{proof}
用反证法，如果$X\in Fire(\alpha')$且$Length(\alpha')=1$。那么$X$可以会在别的进程变量都消失后再被激发，就有$X\in Tail(\alpha)$，矛盾。
\end{proof}

同时，引理\ref{lemma:fire}也是十分自然的：

\begin{lem}\label{lemma:fire}
给定tnPA进程$(\alpha,\Delta)$。那么对于所有$X\in Var(\alpha)$，存在$(\beta,\Delta)$，满足$\alpha\act{}^{*}\beta$，且$X\in Fire(\beta)$。
\end{lem}

\begin{proof}
由$Fire$函数的定义直接显然成立。
\end{proof}

在我们考虑解决tnPA进程的Regularity问题时，希望找到一个充分必要条件。由引理\ref{lemma:infi-path-2}中介绍的必要条件，我们首先希望能找到那种有潜在生成无限种不同语言(Lexically)上不同的进程表达式能力的进程变量。然后我们再去证明这些表达式间的互不互模拟性，从而证明其充分性。

根据这种思路，我们给出关于能使进程\emph{增长(Growing)}的进程变量的定义\ref{def:grow-var}：

\begin{defn}[增长变量 Growing Variable]\label{def:grow-var}
给定一个tnPA进程的规则集合$\Delta$，对于一个变量$X\in Var(\Delta)$，如果存在$\alpha$，满足$X\act{}^{*}\alpha$，$X\in Fire(\alpha)$且$\Length(\alpha)\geq 2$。那么我们称$X$是\emph{增长的(Growing)}。
\end{defn}

\section{转换关系树}
\label{sec:trans-tree}

接下来，我们将会证明在tnPA中，Growing的进程变量就是导致进程状态无限性的原因。再回顾一下引理\ref{lemma:infi-path}中的提供的思路，当我们希望验证状态的无限性时，我们只需要考虑那种无限长的形如$\alpha\act{a_0}\alpha_1\act{a_1}\alpha_2\act{a_2}\ldots$，且满足$\alpha_i\not\weq \alpha_j$ for $i\neq j$的动作路径\mathcal{P}。为了考察路径中那些进程表达试的长度，我们将使用一个树状的结构对其进行表示，我们称之为\emph{转换关系树(Transition Tree)}，记做$T_{\mathcal{P}}$，在定义\ref{def:trans-tree}中利用归纳法，我们给出其严格的定义。利用$T_{\mathcal{P}}$，我们可以准确刻画路径$\mathcal{P}$中连续出现的变量之间的关系。这些信息对我们接下来的证明是有很大用处的。

\begin{defn}[转换关系树]\label{def:trans-tree}

给定一个tnPA进程$(\alpha,\Delta)$和一个形如$\alpha\act{a_0}\alpha_1\act{a_1}\alpha_2\act{a_2}\ldots$.的状态转换路径$\mathcal{P}$
一个\emph{转换关系树(Transition Tree)}，$T_{\mathcal{P}}=(V,E)$定义如下：
\begin{enumerate}
\item $V$ 是结点的集合，它们由$Var(\Delta)\cup \{R\}$进行标号，其中 $R$表示树根的特殊标号。
\item $E$ 是树中边的集合
\item 路径$\mathcal{P}$中每一个状态，例如$\alpha_j$，被树里的第$j+1$层记录，记做$Level_{j+1}$。这层中的节点被$\alpha_j$中的变量所标记，如果重复出现，则重复标记。
\end{enumerate}

$T_{\mathcal{P}}$的拓扑结构(Topological Structure)可以利用树的层数$i$进行归纳定义。
\begin{enumerate}
\item 当$i=0$：为树根，标记为$R$。
\item 当$i=1$：这一层对应了进程的初始状态$\alpha_0$。
\item 当$i>1$: 我们假设$Level_i$ 上所有节点都已经被定义，接着我们试图定义$Level_{i+1}$上的所有节点。我们现在定义$Level_i$上所有节点的子节点的规则：

根据定义\ref{def:pa}中PA的操作语义，我们知道对于一步转换$\alpha_{i-1}\act{a_i}\alpha_{i}$，一定存在一个变量，假如是$A\in Var(\alpha_{i-1})$和一条转换规则$A\act{a_i}\gamma_i\in\Delta$被激发。我们称这个变量$A$为$\alpha_{i-1}$中的\emph{激发变量(Active Variable)}，对应的树中的节点为$Level_i$中的\emph{激发节点(Active Node)}。

我们根据此将$Level_i$中所有节点$N\in V$分成两类分别定义其子节点的标号规则：
\begin{enumerate}
\item 如果$N$不是一个激发节点。那么$N$只有一个儿子节点，标号和$N$相同。而且，一条在它们之间连一条边来表示他们之间的标号继承关系。
\item 如果$N$是一个激发节点。我们假设它对应的进程变量为$A$，而相应的转换规则为$A\act{a_i}\gamma_i$。令$n=Length(\gamma_i)$。如果$n>0$，那么节点$N$有$n$个子节点，否则它是一个叶子节点。它的第$k$个子节点的标号就是$\gamma_i$中从左到右的第$k$个变量。
\end{enumerate}
\end{enumerate}
\end{defn}

观察这个定义，我们可以看出进程转换中标号变量的继承关系的信息可以在树中表示出，而且保留了一部分的进程的结构信息。下面的引理\ref{lemma:children}告诉了我们这样的子节点的排列给我们带来的一些信息。

\begin{lem}\label{lemma:children}
给定一个转换关系树$T_{\mathcal{P}}$，$N$是$\Level_{i+1}$层中的一个标号为$A$的激发节点，其对应的规则是$A\act{a_i}\gamma_i$。它的儿子节点从左到右分别为$B_1,B_2,\ldots,B_n$。假设 $Tail(\gamma_i)=\{B\}$，那么$N$的最后一个子节点的标号就是被阻塞的进程变量$B$。
\end{lem}

\begin{proof}
很明显，这个性质可以由定义\ref{def:tail}和定义\ref{def:trans-tree}中阻塞变量以及转换关系树的定义中得出。

从$Tail(\gamma_i)$的定义我们知道：
\begin{itemize}
	\item 如果$Length(\gamma_i)=1$ 那其中唯一的变量即为阻塞变量，

	\item 否则，$\gamma_i$ 的结构有两种可能性：$\gamma_i=\beta_1.\beta_2$或者$\gamma_i=\beta_1\llfloor\beta_2$. 在这两种情况下，阻塞的变量只能出现在右边的进程中。所以显然被阻塞的变量只能出现在最右边的儿子的标号中。
\end{proof}

更进一步分析，从$T_{\mathcal{P}}$中我们还可以的到那些潜在会增长的变量的信息。这些节点有两个或两个以上的子节点，我们称它们为\emph{分枝节点(Branching Nodes)}。这些节点在分析增长变量的过程中起到了十分重要的作用。为了分析的方便，在定义\ref{def:finite}，我们为每个节点定义一个辅助的集合。

\begin{defn}[Finite 集合]\label{def:finite}
给定一个转换关系树$T_{\mathcal{P}}$，对于每个节点$N$，集合$Finite(N)\subseteq Var(\Delta)$由在树的层次归纳定义如下：
\begin{enumerate}
\item 如果$N$是$T_{\mathcal{P}}$的树根，那么$Finite(N)=Var(\Delta)$。
\item 否则，我们假设$N$的父节点是$M$：
\begin{enumerate}
\item 如果$M$不是分枝节点，那么$Finite(N)=Finite(M)$。
\item 如果$M$是分枝节点，而且$N$在$M$中未被阻塞，那么$Finite(N)=Finite(M)-\{Label(M)\}$。
\item 如果$M$是分枝节点，而且$N$在$M$中被阻塞，那么$Finite(N)=Finite(M)$。
\end{enumerate}
\end{enumerate}
\end{defn}

$Finite(N)$集合刻画了使得以$N$为根节点的子树能保持有限性质的那些$N$的后代。这一性质在引理\ref{lemma:finite}中得到了应用。

\begin{lem}\label{lemma:finite}
给定一个转换关系树$T_{\mathcal{P}}$，对于每一个节点$N$，若$Label(N)\notin Finite(N)$，那么$Label(N)$是一个增长变量。
\end{lem}

\begin{proof}
我们根据$Finite(N)$的生成过程来证明这个结论。假设$Label(N)=X$。由定义\ref{def:finite}，我们可以发现从这个集合中去掉变量$X$的唯一可能是，存在另一个节点$M$，满足以下条件：
\begin{enumerate}
\item $M$是$N$在树中的一个\emph{祖先(Ancestor)}。
\item $Label(M)=X$。
\item $M$是一个分支节点且有一个子节点$O$，满足$O$在$M$中未被阻塞，且$N$由$O$被继承。
\end{enumerate}

由于$O$在$M$中未被阻塞，那么所有$O$子孙，包括$N$，不会在$M$中被阻塞。即$X\notin Tail(X)$，于是存在$\alpha$，满足$X\act{}^{*}\alpha$，$X\in Fire(\alpha)$且 $Length(\alpha)\geq 2$。

由定义\ref{def:grow-var}，我们可以得到$X$是一个增长变量。
\end{proof}

为了证明定理\ref{thm:tnpa-equiv}中本章的主要结论，接下来我们针对转换关系树$T_{\mathcal{P}}$，给出关于它的概念，用来刻画它的一些细节，以方便更精细的分析。在定义\ref{def:seg}中我们将树分\emph{段(Segment)}进行研究。

\begin{defn}[树的分段 Breaking Levels and Segments]\label{def:seg}
给定一棵转换关系树$T_{\mathcal{P}}$，
\begin{itemize}
	\item 我们称那些只包含一个节点的层为\emph{分割层(Breaking Levels)}，这些层中的节点为\emph{分割节点(Breaking Nodes)}。
	\item 通过分割节点，我们可以将树$T_{\mathcal{P}}$分\emph{段(Segments)}。

一个段$S$是$T_{\mathcal{P}}$中的一个子图，由分割层进行分割。每个分割节点都是一个段的\emph{起始节点(Starting Node)}，直到下一个分割节点，\emph{结束节点(Ending Node)}，以前的所有节点和边都属于这个段。如果不存在这样的结束节点，那么该段包含从起始节点向下的所有节点和边。

这里我们用$Seg(N)$表示一个以$N$为起始节点的段。
\end{itemize}
\end{defn}

下面我们在定义\ref{def:width}中给出另一个用来衡量的树的宽度结构的函数，我们可以通过类似的定义来衡量段的相关性质。

\begin{defn}[树的宽度 Width]\label{def:width}
给定一个以$N$为根节点的转换关系树$T_{\mathcal{P}}$，树的宽度函数$WidthT(N)$定义如下：
\begin{eqnarray*}
WidthT(N) &=& \left\{ \begin{array}{ll}
    w& \mbox{$card(Level_i)$的最大值, $i\in \mathbb{N}\cup\{0\}$}\\
    \infty &\mbox{如果不存在最大值}
    \end{array}\right.
\end{eqnarray*}
\end{defn}

其中函数$card(S)$表示集合S中互不相同的元素的个数，即集合的基数(Cardinality)。

类似的我们可以为一个段$Seg(N)$定义它的宽度函数$WidthS(N)$，或者为$T_{\mathcal{P}}$的一个以$N$为根节点的子树定义它的宽度函数$WidthT(N)$。

下面在定义\ref{def:branch-d}中，我们为转换关系树定义了一个\emph{分枝度(Branching Degree)}，它的最大值被输入的tnPA的规则所限定。

\begin{defn}[Branching Degree]\label{def:branch-d}
给定一个转换关系树$T_{\mathcal{P}}$，它的\emph{分枝度(Branching Degree)}，为它节点的子节点个数的最大值，即其中分枝数的最大值。我们用$\mathbf{D}$表示这个数。
\end{defn}

每个节点的分枝数由它对应被激活的转换规则所决定，所以$\mathbf{D}$的最大值由输入中进程的规则$\Delta$所限定，不会超过输入的最长的规则的长度，所以它的上界(Upper Bound)是\emph{有限(Finite)}的且可以\emph{有效计算(Effectively Computable)}的。

利用转换关系树的辅助，我们可以对进程的行为作出更细致的分析。这是一个关于进程转换路径的语法上的表示，它可以更精确地刻画其中进程表达式的“长度”，并用子节点的顺序来记录部分进程变量执行顺序的信息。通过本节的分析，我们定义了一些转换关系树上有用的结构和概念，接下来，我们就可以试图证明造成进程状态增长的原因。

\section{等价条件证明}
\label{sec:equiv-proof}

本节中我们将利用第\ref{sec:grow-prop}节中的增长变量和第\ref{sec:trans-tree}节中的转换关系树，来证明一个tnPA进程非Regular的等价条件。

首先我们需要证明引理\ref{lemma:width}，它给了不包含增长变量的进程所对应的转换关系树中的所有子树的宽度一个上界。

\begin{lem}\label{lemma:width}
给定一个tnPA进程$(\alpha,\Delta)$和它的一个转换关系树$T_{\mathcal{P}}$。如果$Var(\Delta)$不包含任何增长变量，那么$T_{\mathcal{P}}$中的每个节点$N$，满足$WidthT(N)\leq D^{n-1}$，其中 $n=card(Finite(N))$。
\end{lem}

\begin{proof}
我们显然可以得到$n>0$，如果假设$n=0$，那么$Finite(N)=\emptyset$。由引理\ref{lemma:finite}，由于$Label(N)\notin\Finite(N)=\emptyset$，可知$Lable(N)$是一个增长变量，和假设矛盾。所以我们之考虑$n>0$的情况。

现在我们可以利用关于$n$的归纳法进行证明：
\begin{enumerate}
\item $n=1$： 这种情况我们只要证明$WidthT(N)=\mathbf{D}^{n-1}=1$。

假设以$N$为跟的子树中有一个分枝节点$N_1$。不妨设$Finite(N)=\{X\}$，那么有$Finite(N_1)=\{X\}$。这是因为$N_1$是$N$的一个后代节点，而且$N_1$不可以是一个增长节点，根据引理\ref{lemma:finite}，可知$Label(N_1)=X$。

由假设$N_1$是一个分枝节点，那么$N1$至少有一个子节点$N_1^{'}$在$N_1$中不被阻塞，于是有$Finite(N_1^{'})=\emptyset$。且有$Label(N_1^{'})=X_1\notin Finite(N_1^{'})$，则$X_1$只能是一个增长节点。产生矛盾。

这就意味着，这棵子树中不可能包含任何分枝节点，即$WidthT(N)=\mathbf{D}^{n-1}=1$。
\item $n>1$： 这种情况我们只要证明以$N$为根节点的子树中的每一个段的宽度都不会超过$\mathbf{D}^{n-1}$，其中$n=card(Finite(N))$。另$S$为该子树中一个以$N_1$为起始节点的段。我们显然有$card(Finite(N_1))\leq n$。

下面我们考虑$N_1$的四种可能情况，从而找到$WidthS(N_1)$的上界：
\begin{enumerate}
\item 若$N_1$是一个叶子节点。

那么显然$WidthS(N_1)=1$
\item 若$N_1$不是叶子节点，也不是一个分枝节点。

那么它唯一的儿子节点就是段$S$的结束节点，可知$WidthS(N_1)=1$。
\item 若$N_1$是一个分枝节点，而且$N_1$中没有子节点被阻塞。

令$N_1^{'}$为$N_1$的一个子节点，我们有$Finite(N_1^{'})=Finite(N_1)-\{Label(N_1)\}$。所以有$card(Finite(N_1^{'}))\leq n-1$。

由归纳假设，我们有$WidthT(N_1^{'})\leq \mathbf{D}^{n-2}$。$N_1$最多有$\mathbf{D}$个子节点，所以有$WidthS(N_1)\leq WidthT(N_1)\leq \mathbf{D}\times\mathbf{D}^{n-2}=\mathbf{D}^{n-1}$。
\item 若$N_1$是一个分枝节点而且有一个被阻塞的子节点$N_b$。

我们首先考虑除去$N_b$以外的那些子节点。不妨设$N_1^{'}$为这样的节点，根据上一种情况的证明，我们有$WidthT(N_1)\leq\mathbf{D}^{n-2}$

然后对于那个被阻塞的节点$N_b$，我们试图证明它在直到段$S$之前的子孙节点都不会有任何分枝节点。

如果$N_B$的子孙节点中有一个分枝节点$N_b^{'}$它属于段$S$但它不是结束节点$N_e$。由于$N_b^{'}$是分枝节点，那么他是一个激活的节点。另一方面，我们有$N_b$是被阻塞的节点，所以它的子孙节点只能在其他节点所对应的变量都消失之后才能被激活。我们可以断言$N_b^{'}$必须是$N_e$或者是它的一个子孙，这是由于$N_e$是$N_b$下面第一个分割节点。所以$N_b^{'}$不可能属于$S$，推出矛盾。

这就意味着$N_b$在$N_e$之前的所有子孙节点都不是分枝节点, 所以$N_b$对$WidthS(N_1)$的贡献只有$1$。

最后我们可以总结这种情况下$WidthS(N_1)\leq (\mathbf{D}-1)\times \mathbf{D}^{n-2}+1\leq \mathbf{D}^{n-1}$。
\end{enumerate}
于是我们有$WidthT(N)\leq \mathbf{D}^{n-1}$。
\end{enumerate}
本引理得证。
\end{proof}

有了之前的准备，我们现在就开始证明本章中的主要结论，定理\ref{thm:tnpa-equiv}。它为tnPA的$\weq_{REG}$和$\beq_{REG}$问题证明了一个充分必要条件。这是进行Regularity判定算法设计的理论基础，它确保了第\ref{chap:tnpa-alg}章中算法的正确性。

\begin{thm}[tnPA $\weq_{REG}$的等价条件]\label{thm:tnpa-equiv}
一个tnPA进程$(\alpha,\Delta)$满足$\weq_{REG}$\emph{当且仅当}$Var(\Delta)$不包含任何增长变量。
\end{thm}

\begin{proof}
我们分别证明充分性和必要性。
\begin{itemize}
	\item $\Rightarrow$ 假设tnPA进程中存在增长变量，为$X\in Var(\Delta)$。我们需要证明利用$\Delta$中的规则可以到达无限个互不弱互模拟的的状态。

有假设中$(\alpha,\Delta)$的定义，可知存在某个状态$\alpha_x$，满足$\alpha\act{}^{*}\alpha_x$，且$X\in Var(\alpha_x)$。由引理\ref{lemma:fire}可知，存在一个状态$\beta_x$，满足$\alpha\act{}^{*}\alpha_x\act{}^{*}\beta_x$，且$X\in Fire(\beta_x)$。

我们知道，互模拟的进程的Norm必然想等，由引理\ref{lemma:infi-path-3}可知，我们只需证明对于任意$k\in \mathcal{N}$，存在一个可达的状态$\beta_k$满足$\|\beta_k\|\geq k$。

这里我们选择状态$\beta_x$进行分析，令$X$为激活变量。由于$X$是一个增长变量，所以存在一个可达的状态$\beta_1^{'}$，满足$X\act{}^{*}\beta_1^{'}$，$X\in Fire(\beta_1^{'})$，且$Length(\beta_1^{'})\geq 2$。

所以存在一个状态$\beta_1$，形如$\beta_x\act{}^{*}\beta_1$，我们将其中被激活的变量$X$转换为$\beta_1^{'}$。另外，我们有$X\in Fire(\beta_1)$，因为$X\in Fire(\beta_1^{'})$，且$Fire(\beta_1^{'})\subseteq Fire(\beta_1)$。

这样我们可以重复这一过程，从$\beta_1$中构造出$\beta_2,\beta_3\ldots$，这些状态满足$X\in Fire(\beta_i)$，且$Length(\beta_{i+1})>Length(\beta_i)(i=2,3,\ldots)$。即满足$Length(\beta_k)\geq k$。

由假设，我们有$(\alpha,\Delta)$是Totally Normed，所以有对于每一个变量$Y\in Var(\beta_k)$，满足$\|Y\|\geq 1$。结合之前$Length(\beta_k)\geq k$的结论，我们就可以从Totally Normed性质得出$\|\beta_k\|\geq k$。

必要性得证。
	
	\item $\Leftarrow$ 我们只需要证明，如果一个tnPA进程$(\alpha,\Delta)$不满足$\weq_{REG}$，那么一定存在一个增长变量$X\in Var(\Delta)$。

我们基本的证明策略是找到一个不包含增长变量的进程所能产生语言上互不相同的表达式数量的上界。假设一个tnPA进程$(\alpha,\Delta)$不包含任何一个增长变量，那么我们只需要证明它是$\weq_{REG}$的。或者我们证明如果它不是$\weq_{REG}$的，那么必然存在矛盾。

由引理\ref{lemma:infi-path}，这个目标等价于证明如果存在一个形如$\alpha\act{a_0}\alpha_1\act{a_1}\alpha_2\act{a_2}\ldots$的无限长度转换动作序列$\mathcal{P}$，那么存在$i\neq j$且$\alpha_i\weq \alpha_j$。

现在令$T_{\mathcal{P}}$为$\mathcal{P}$的转换关系树，我们进一步对树的宽度进行分析，以找到该进程潜在的能生成的进程表达式的长度的上限。

令$N$为$T_{\mathcal{P}}$的根节点。应用引理\ref{lemma:width}，可知$WidthT(N)\leq \mathbf{D}^{n-1}$，其中$n=card(Finite(N))$，且$\mathbf{D}$为$T_{\mathcal{P}}$的分枝度。

显然，我们有$card(Finite(N))\leq card(Var(\Delta))$。那么有$Length(a_i)\leq WidthT(N)\leq \mathbf{D}^{card(Var(\Delta))-1}=m$其中，$i=1,2,\ldots$。这里$m$是一个由输入进程规则决定的常数，也就是进程从初始状态所可能生成的进程的长度由这个常数所限定。所以在$\mathcal{P}$中最多只有有限(Finite)个语言(Lexically)上互不相同的表达式。

最后，必然存在$i\neq j$，满足$\alpha_i\equiv \alpha_j$，蕴含了$\alpha_i\weq \alpha_j$。产生矛盾。

充分性得证。
\end{itemize}
综上，本定理得证。
\end{proof}

这个证明中有两处涉及到了$\weq$，首先在必要性的证明中如两个tnPA进程Norm不相等，那么它们必然不是$\weq$的。同理，它们也不是$\beq$的。

在充分性的证明中，我们用到了如果两个进程是$\equiv$那么必然是$\weq$的，同理，显然对于$\equiv$的两个进程，也满足$\beq$。综上所述，该定理对与$\beq_{REG}$一样成立，我们有推论\ref{cor:tnpa-equiv}：

\begin{cor}[tnPA $\beq_{REG}$的等价条件]\label{cor:tnpa-equiv}
一个tnPA进程$(\alpha,\Delta)$满足$\beq_{REG}$\emph{当且仅当}$Var(\Delta)$不包含任何增长变量。
\end{cor}

需要注意的是，该证明对更加一般的nPA模型并不成立。因为我们在必要性的证明中用到了tnPA中所有进程变量的Norm至少为$1$的限定条件。如果去掉这一限定，那么对于Norm为$0$的那些进程，我们就不能用进程表达式语言上的长度限制来得到Norm上的下界了。如果要克服这一问题，我们需要对进程的行为进行更精细的分析，以得到更强大的性质。

在第\ref{chap:tnpa-alg}章中，我们将集中讨论如何找到一个有效的算法对该条件进行判定，并分析该算法的时间复杂度，从而找到解决tnPA的Regularity问题的具体算法。

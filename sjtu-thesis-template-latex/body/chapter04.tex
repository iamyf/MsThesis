\chapter{Totally Normed PA Regularity的充要条件}
\label{chap:tnpa-equiv}

在这一章中，我们将具体讨论和证明tnPA的$\weq_{REG}$和$\beq_{REG}$问题的充分必要条件，定理\ref{thm:tnpa-equiv}。这里将\cite{Kucera1996}中用于判定nPA的$\seq_{REG}$的一些技术应用到我们讨论的问题中，起到了很好的效果。这里证明的充要条件将会在第\ref{chap:tnpa-alg}章中的多项式算法中被判定。

\section{PA模型定义}
\label{sec:pa-def}

为了问题研究的严谨性，我们这里在PRS的一般性定义\ref{def:prs}的基础上，给出PA的严格定义。

\begin{defn}[PA 定义]\label{def:pa}
一个PA系统是一个形如$X\act{a}\alpha$的有限转换规则的集合$\Delta$，一个PA表达式的语法定义为：
$$\alpha,\beta\Coloneqq X\mid \alpha.\beta\mid\alpha\parallel\beta\mid\alpha\llfloor\beta$$
其中用大写英文字母表示进程变量,希腊字母表示进程项(状态)。
相应的操作语义可以定义为一下规则
\[\begin{array}{ccc}
$\inference{\alpha\act{a}\beta\in\Delta}{\alpha\act{a}\beta}$ &
$\inference{\alpha\act{a}\alpha^{'}}{\alpha.\beta\act{a}\alpha^{'}.\beta}$ &
$\inference{\alpha\act{a}\alpha^{'}}{\alpha\| \beta\act{a}\alpha^{'}\|\beta}$ \\
 \\
$\inference{\beta\act{a}\beta^{'}}{\alpha\| \beta\act{a}\alpha \| \beta^{'}}$ &
$\inference{\alpha\act{a}\alpha^{'}}{\alpha\llfloor \beta\act{a}\alpha^{'}\|\beta}$ &
\end{array}\]
一个PA进程可以具体表示为$(\alpha,\Delta)$。
\end{defn}

我们用函数$Var(\_)$表示$\_$中所包含的进程变量。

我们要求一个PA中定义的所有进程变量$X_i\in Var(\Delta)$存在一个可达的状态$\alpha$满足$\X_i\in Var(\alpha)$。

另外，我们用$Length(\alpha)$表示$\alpha$中出现的进程变量的个数。

同时，我们限制在章里我们所关心的PA进程都是Totally Normed的。同时如果不特殊说明，我们证明中所用到的等价关系都是弱互模拟关系$\weq$。这些证明对于$\beq$都是成立的。

\section{进程状态的增长}
\label{sec:grow-prop}

给定一个tnPA的进程$(\alpha,\Delta)$，我们希望能找到导致它产生无限中不同状态的进程变量的集合。这些变量导致了进程状态所能产生的增长，是导致进程非Regularity的原因。

我们首先针对一个tnPA进程，定义两个十分有用的函数。

\begin{defn}[Fire 函数]\label{def:fire}
给定一个tnPA进程$(\alpha,\Delta)$
\begin{eqnarray*}
Fire(\alpha) &=& \left\{ \begin{array}{ll}
\emptyset & \mbox{if }\alpha=\epsilon\\
\{X\} & \mbox{if }\alpha=X\\
Fire(\beta_1) & \mbox{if }\alpha=\beta_1.\beta_2\mbox{ or }\alpha=\beta_1\llfloor\beta_2\\
Fire(\beta_1)\cup Fire(\beta_2) & \mbox{if }\alpha=\beta_1\|\beta_2
\end{array}\right.
\end{eqnarray*}
\end{defn}

$Fire()$函数会返回那些当前状态下潜在可以被激发(Active)的进程变量的集合。

\begin{defn}[Tail 函数]\label{def:tail}
给定一个tnPA进程$(\alpha,\Delta)$
\begin{eqnarray*}
Tail(\alpha) &=& \left\{ \begin{array}{ll}
\{X\} & \mbox{if }\alpha=X\\
\emptyset & \mbox{if }\alpha=\epsilon \mbox{ or } \alpha=\beta_1\|\beta_2 \mbox{ where } \beta_1\neq\epsilon\neq\beta_2\\
Tail(\beta_2)-Var(\beta_1) &\mbox{if }\alpha=\beta_1.\beta_2 \mbox{ or }\alpha=\beta_1\llfloor\beta_2\mbox{ where }\beta_1\neq\epsilon\neq\beta_2
\end{array}\right.
\end{eqnarray*}
\end{defn}

$Tail()$函数返回所有在当前状态下被阻塞(Block)，即必须先将别的变量转换成$\epsilon$，最后才能激发的进程变量的集合。

通过观察这两个函数的性质，我们能得到以下性质，引理\ref{lemma:tail}：

\begin{lem}\label{lemma:tail}
假设我们有$X\in Var(\alpha)$满足$X\notin Tail(\alpha)$，那么必然存在$\alpha'$，使得$\alpha\act{}^{*}\alpha'$，且$X\in Fire(\alpha')$且$Length(\alpha')\geq 2$。
\end{lem}

\begin{proof}
用反证法，如果$X\in Fire(\alpha')$且$Length(\alpha')=1$。那么$X$可以会在别的进程变量都消失后再被激发，就有$X\in Tail(\alpha)$，矛盾。
\end{proof}

同时，引理\ref{lemma:fire}也是十分自然的：

\begin{lem}\label{lemma:fire}
给定tnPA进程$(\alpha,\Delta)$。那么对于所有$X\in Var(\alpha)$，存在$(\beta,\Delta)$，满足$\alpha\act{}^{*}\beta$，且$X\in Fire(\beta)$。
\end{lem}

\begin{proof}
由$Fire$函数的定义直接显然成立。
\end{proof}

在我们考虑解决tnPA进程的Regularity问题时，希望找到一个充分必要条件。由引理\ref{lemma:infi-path-2}中介绍的必要条件，我们首先希望能找到那种有潜在生成无限种不同语言(Lexically)上不同的进程表达式能力的进程变量。然后我们再去证明这些表达式间的互不互模拟性，从而证明其充分性。

根据这种思路，我们给出关于能使进程\emph{增长(Growing)}的进程变量的定义\ref{def:grow-var}：

\begin{defn}[增长变量 Growing Variable]\label{def:grow-var}
给定一个tnPA进程的规则集合$\Delta$，对于一个变量$X\in Var(\Delta)$，如果存在$\alpha$，满足$X\act{}^{*}\alpha$，$X\in Fire(\alpha)$且$\Length(\alpha)\geq 2$。那么我们称$X$是\emph{增长的(Growing)}。
\end{defn}

\section{转换关系树}
\label{sec:trans-tree}

接下来，我们将会证明在tnPA中，Growing的进程变量就是导致进程状态无限性的原因。再回顾一下引理\ref{lemma:infi-path}中的提供的思路，当我们希望验证状态的无限性时，我们只需要考虑那种无限长的形如$\alpha\act{a_0}\alpha_1\act{a_1}\alpha_2\act{a_2}\ldots$，且满足$\alpha_i\not\weq \alpha_j$ for $i\neq j$的动作路径\mathcal{P}。为了考察路径中那些进程表达试的长度，我们将使用一个树状的结构对其进行表示，我们称之为\emph{转换关系树(Transition Tree)}，记做$T_{\mathcal{P}}$，在定义\ref{def:trans-tree}中利用归纳法，我们给出其严格的定义。利用$T_{\mathcal{P}}$，我们可以准确刻画路径$\mathcal{P}$中连续出现的变量之间的关系。这些信息对我们接下来的证明是有很大用处的。

\begin{defn}[转换关系树]\label{def:trans-tree}

给定一个tnPA进程$(\alpha,\Delta)$和一个形如$\alpha\act{a_0}\alpha_1\act{a_1}\alpha_2\act{a_2}\ldots$.的状态转换路径$\mathcal{P}$
一个\emph{转换关系树(Transition Tree)}，$T_{\mathcal{P}}=(V,E)$定义如下：
\begin{enumerate}
\item $V$ 是结点的集合，它们由$Var(\Delta)\cup \{R\}$进行标号，其中 $R$表示树根的特殊标号。
\item $E$ 是树中边的集合
\item 路径$\mathcal{P}$中每一个状态，例如$\alpha_j$，被树里的第$j+1$层记录，记做$Level_{j+1}$。这层中的节点被$\alpha_j$中的变量所标记，如果重复出现，则重复标记。
\end{enumerate}

$T_{\mathcal{P}}$的拓扑结构(Topological Structure)可以利用树的层数$i$进行归纳定义。
\begin{enumerate}
\item 当$i=0$：为树根，标记为$R$。
\item 当$i=1$：这一层对应了进程的初始状态$\alpha_0$。
\item 当$i>1$: 我们假设$Level_i$ 上所有节点都已经被定义，接着我们试图定义$Level_{i+1}$上的所有节点。我们现在定义$Level_i$上所有节点的子节点的规则：

根据定义\ref{def:pa}中PA的操作语义，我们知道对于一步转换$\alpha_{i-1}\act{a_i}\alpha_{i}$，一定存在一个变量，假如是$A\in Var(\alpha_{i-1})$和一条转换规则$A\act{a_i}\gamma_i\in\Delta$被激发。我们称这个变量$A$为$\alpha_{i-1}$中的\emph{激发变量(Active Variable)}，对应的树中的节点为$Level_i$中的\emph{激发节点(Active Node)}。

我们根据此将$Level_i$中所有节点$N\in V$分成两类分别定义其子节点的标号规则：
\begin{enumerate}
\item 如果$N$不是一个激发节点。那么$N$只有一个儿子节点，标号和$N$相同。而且，一条在它们之间连一条边来表示他们之间的标号继承关系。
\item 如果$N$是一个激发节点。我们假设它对应的进程变量为$A$，而相应的转换规则为$A\act{a_i}\gamma_i$。令$n=Length(\gamma_i)$。如果$n>0$，那么节点$N$有$n$个字节点，否则它是一个叶子节点。它的第$k$个子节点的标号就是$\gamma_i$中从左到右的第$k$个变量。
\end{enumerate}
\end{enumerate}
\end{defn}

观察这个定义，我们可以看出进程转换中标号变量的继承关系的信息可以在树中表示出，而且保留了一部分的进程的结构信息。下面的引理\ref{lemma:children}告诉了我们这样的子节点的排列给我们带来的一些信息。

\begin{lem}\label{lemma:children}
给定一个转换关系树$T_{\mathcal{P}}$，$N$是$\Level_{i+1}$层中的一个标号为$A$的激发节点，其对应的规则是$A\act{a_i}\gamma_i$。它的儿子节点从左到右分别为$B_1,B_2,\ldots,B_n$。假设 $Tail(\gamma_i)=\{B\}$，那么$N$的最后一个子节点的标号就是被阻塞的进程变量$B$。
\end{lem}

\begin{proof}
很明显，这个性质可以由定义\ref{def:tail}和定义\ref{def:trans-tree}中阻塞变量以及转换关系树的定义中得出。

从$Tail(\gamma_i)$的定义我们知道：
\begin{itemize}
	\item 如果$Length(\gamma_i)=1$ 那其中唯一的变量即为阻塞变量，

	\item 否则，$\gamma_i$ 的结构有两种可能性：$\gamma_i=\beta_1.\beta_2$或者$\gamma_i=\beta_1\llfloor\beta_2$. 在这两种情况下，阻塞的变量只能出现在右边的进程中。所以显然被阻塞的变量只能出现在最右边的儿子的标号中。
\end{proof}

更进一步分析，从$T_{\mathcal{P}}$中我们还可以的到那些潜在会增长的变量的信息。这些节点有两个或两个以上的子节点，我们称它们为\emph{分枝节点(Branching Nodes)}。这些节点在分析增长变量的过程中起到了十分重要的作用。为了分析的方便，在定义\ref{def:finite}，我们为每个节点定义一个辅助的集合。

\begin{defn}[Finite 集合]\label{def:finite}
给定一个转换关系树$T_{\mathcal{P}}$，对于每个节点$N$，集合$Finite(N)\subseteq Var(\Delta)$由在树的层次归纳定义如下：
\begin{enumerate}
\item 如果$N$是$T_{\mathcal{P}}$的树根，那么$Finite(N)=Var(\Delta)$。
\item 否则，我们假设$N$的父节点是$M$：
\begin{enumerate}
\item 如果$M$不是分枝节点，那么$Finite(N)=Finite(M)$。
\item 如果$M$是分枝节点，而且$N$在$M$中未被阻塞，那么$Finite(N)=Finite(M)-\{Label(M)\}$。
\item 如果$M$是分枝节点，而且$N$在$M$中被阻塞，那么$Finite(N)=Finite(M)$。
\end{enumerate}
\end{enumerate}
\end{defn}

$Finite(N)$集合刻画了使得以$N$为根节点的子树能保持有限性质的那些$N$的后代。这一性质在引理\ref{lemma:finite}中得到了应用。

\begin{lem}\label{lemma:finite}
给定一个转换关系树$T_{\mathcal{P}}$，对于每一个节点$N$，若$Label(N)\notin Finite(N)$，那么$Label(N)$是一个增长变量。
\end{lem}

\begin{proof}
我们根据$Finite(N)$的生成过程来证明这个结论。假设$Label(N)=X$。由定义\ref{def:finite}，我们可以发现从这个集合中去掉变量$X$的唯一可能是，存在另一个节点$M$，满足以下条件：
\begin{enumerate}
\item $M$是$N$在树中的一个\emph{祖先(Ancestor)}。
\item $Label(M)=X$。
\item $M$是一个分支节点且有一个子节点$O$，满足$O$在$M$中未被阻塞，且$N$由$O$被继承。
\end{enumerate}

由于$O$在$M$中未被阻塞，那么所有$O$子孙，包括$N$，不会在$M$中被阻塞。即$X\notin Tail(X)$，于是存在$\alpha$，满足$X\act{}^{*}\alpha$，$X\in Fire(\alpha)$且 $Length(\alpha)\geq 2$。

由定义\ref{def:grow-var}，我们可以得到$X$是一个增长变量。
\end{proof}

为了证明定理\ref{thm:tnpa-equiv}中本章的主要结论，接下来我们针对转换关系树$T_{\mathcal{P}}$，给出关于它的概念，用来刻画它的一些细节，以方便更精细的分析。


\section{等价条件证明}
\label{sec:equiv-proof}

\begin{thm}[tnPA $\weq_{REG}$和$\beq_{REG}$的等价条件]\label{thm:tnpa-equiv}

\end{thm}
